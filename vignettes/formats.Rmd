---
title: "Understanding formats in `tern` and `junco` analysis functions"
date: "2025-07-10"
author: "Ilse Augustyns"
output:
    rmarkdown::html_document:
        theme: "spacelab"
        highlight: "kate"
        toc: true
        toc_float: true
vignette: >
  %\VignetteIndexEntry{formats}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
editor_options:
  markdown:
      wrap: 72
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  collapse = TRUE,
  comment = "#>"
)

# TODO update varying precision code when design has been chosen
# TODO add to backlog junco defaults for numerical vars jj rules are not implemented for all stats
```

```{r packages, message=FALSE}
library(tern)
library(junco)
library(dplyr)
```


## Introduction

Both `tern` and `junco` R package provides functions to create common analyses from clinical trials in R and these functions have default formatting arguments for displaying the values in the output a specific way.

Format specifications can be based upon the `formatters` build-in format strings, using `xx-style` notation. See `formatters::list_valid_format_labels()` for an overview of the build-in string formats. Another approach for format specificiation is via formatting functions. With formatting functions, formats are capable of handling logical statements, allowing for more fine-tuning of the output displayed. 
Depending on what type of value is being displayed, and what that value is, the format of the output will change. 
See [tern vignette on formatting](https://insightsengineering.github.io/tern/latest-tag/articles/tern_formats.html) for a more in depth article on formatting functions.  

Current vignette goes back to the basics of formatting specifications in custom analysis function, versus `tern`/`junco` analysis functions. 

We will start with demonstratation of various basic approaches for writing an `afun` with an argument `.stats` for the choice of statistics to be presented, and an argument `.formats` for the formats to be used. All of the `afuns` will be for the same simple `sfun` `sfun_simple` as defined below. It is a reduced version of the `tern` `sfun` `s_summary()`, restricted to 8 out of the 29 statistics only.

```{r simple sfun}
sfun_simple <- function(x){
  my_stats <- c("n", "mean", "mean_se", "median", "range", "quantiles", "median_range", "mean_ci_3d")
  stats <- tern:::s_summary(x)
  stats <- stats[my_stats]
}
```

The data that we will use is the following `adsl` dataset, with 1 continuous variable.

```{r datasetup}
adsl <- ex_adsl %>% select("USUBJID", "ARM", "AGE")
```

## Format specifications in custom analysis function
### basic approach
In the most basic approach, the analysis function has defaults defined for both `.stats` and `.formats` arguments. Inside the analysis function, no further manipulations are done on the `.formats` argument.

```{r simple afun}
afun_simple <- function(df, 
                        .var, 
                        .stats = c("n", "mean", "mean_se", "median", "range"), 
                        .formats = c("xx", "xx.x", "xx.x (xx.x)", "xx.x", "xx.x - xx.x")){
  x <- df[[.var]]
  stats <- sfun_simple(x)[.stats]
  
  # for completeness, no discussion on this topic
  .labels_all <- c(n = "N",
    mean = "Mean",
    mean_se = "Mean (SE)",
    median = "Median",
    range = "Min - max",
    ## define a format for all stats from the used sfun_simple function
    quantiles = "Q1 - Q3", 
    median_range = "Median (min - max)", 
    mean_ci_3d = "Mean (95%CI)"
  )
  .labels <- .labels_all[.stats]  
  
  in_rows(.list = stats, .formats = .formats, .labels = .labels)
}
```

With this simplistic approach, the user will have the ensure the arguments for `.stats` and `.formats` are aligned regarding specified statistics and formats, and the order of the `.formats` needs to be aligned with the order of the `.stats`.

Both of the below calls work fine with this basic approach.
```{r apply afun_simple}
basic_table() %>% 
  split_cols_by("ARM") %>% 
  analyze(vars = "AGE", afun_simple)  %>% 
  build_table(adsl)

basic_table() %>% 
  split_cols_by("ARM") %>% 
  analyze(vars = "AGE", afun_simple, 
          extra_args = list(
            .stats = c("n", "mean", "mean_se", "quantiles"),
            .formats = c(n = "xx", 
                         mean = "xx.x",
                         mean_se = "xx.x (xx.x)",
                         quantiles = "xx.x - xx.x"))) %>% 
  build_table(adsl)
```
Below calls will result in errors due to order of .stats and .formats not aligned in the first call, or number of .stats and .formats not the same in the second call.

```{r apply afun_simple issue}
# basic_table() %>% 
#   split_cols_by("ARM") %>% 
#   analyze(vars = "AGE", afun_simple, 
#           extra_args = list(
#             .stats = c("n", "mean", "mean_se"),
#             .formats = c(n = "xx", 
#                          mean_se = "xx.x (xx.x)", 
#                          mean = "xx.x")))  %>% 
#   build_table(adsl)

# basic_table() %>% 
#   split_cols_by("ARM") %>% 
#   analyze(vars = "AGE", afun_simple, 
#           extra_args = list(
#             .stats = c("n", "mean", "mean_se")))  %>% 
#   build_table(adsl)

```

### improvement 1 to basic approach
Both issues can be avoided with one simple adjustment to the analysis function definition. See the 1-line code `.formats <- .formats[.stats]`.

```{r afun_simple2}
afun_simple2 <- function(df,
                         .var,
                         .stats = c("n", "mean", "mean_se", "median", "range"),
                         .formats = c(
                           n = "xx",
                           mean = "xx.x",
                           mean_se = "xx.x (xx.x)",
                           median = "xx.x",
                           range = "xx.x - xx.x",
                           ## define a format for all stats from the used sfun_simple function
                           quantiles = "xx.x - xx.x", 
                           median_range = "xx.x (xx.x - xx.x)", 
                           mean_ci_3d = "xx.x (xx.x - xx.x)"
                         )) {
  x <- df[[.var]]
  stats <- sfun_simple(x)[.stats]
  
  # this line will ensure .formats is restricted to requested .stats
  # and the order of the .formats specification is no longer important
  .formats <- .formats[.stats]
  
  .labels_all <- c(n = "N",
    mean = "Mean",
    mean_se = "Mean (SE)",
    median = "Median",
    range = "Min - max",
    ## define a format for all stats from the used sfun_simple function
    quantiles = "Q1 - Q3", 
    median_range = "Median (min - max)", 
    mean_ci_3d = "Mean (95%CI)"
  )
  .labels <- .labels_all[.stats]  
  
  in_rows(.list = stats, .formats = .formats, .labels = .labels)
}
```
With this update, the same code now can be executed.

```{r apply afun_simple2 }
basic_table() %>%
  split_cols_by("ARM") %>%
  analyze(vars = "AGE", afun_simple2,
          extra_args = list(
            .stats = c("n", "mean", "mean_se"),
            .formats = c(n = "xx",
                         mean_se = "xx.x (xx.x)",
                         mean = "xx.x")))  %>%
  build_table(adsl)

basic_table() %>%
  split_cols_by("ARM") %>%
  analyze(vars = "AGE", afun_simple2,
          extra_args = list(
            .stats = c("n", "mean", "quantiles")))  %>%
  build_table(adsl)

```

There are still problems with this approach of `.formats` specifications. If the user is fine with all but one of the default `.formats`, the formats for all requested statistics would have to be provided. Eg, we want to include 3 statistics : n, mean_se, quantiles, and only for mean_se we'd like to use another format.
The following code will not work.

```{r simple_afun2 issue}
# basic_table() %>%
#   split_cols_by("ARM") %>%
#   analyze(vars = "AGE", afun_simple2,
#           extra_args = list(
#             .stats = c("n", "mean_se", "quantiles"),
#             .formats = c(mean_se = "xx.x (xx.xx)")))  %>%
#   build_table(adsl)
```
Instead, the formats of all 3 requested statistics have to be included.

```{r simple_afun2 resolution issue}
basic_table() %>%
  split_cols_by("ARM") %>%
  analyze(vars = "AGE", afun_simple2,
          extra_args = list(
            .stats = c("n", "mean_se", "quantiles"),
            .formats = c(mean_se = "xx.x (xx.xx)", 
                         n = "xx",
                         quantiles = "xx.x - xx.x")))  %>%
  build_table(adsl)
```

### improvement 2 to basic approach
In order to avoid that users have to specify all `.formats` when just 1 statistic is not according to the default formatting, the following simple adjustments to the analysis function definition can be made.
Note that the default format definitions are now in the body of the function, rather than in the argument default value.
```{r afun_simple3}
afun_simple3 <- function(df,
                         .var,
                         .stats = c("n", "mean", "mean_se", "median", "range"),
                         .formats = NULL) {
  x <- df[[.var]]
  stats <- sfun_simple(x)[.stats]
  
  # set default formats for all stats from the s-function
  .formats_defaults_all <- c(n = "xx",
    mean = "xx.x",
    mean_se = "xx.x (xx.x)",
    median = "xx.x",
    range = "xx.x - xx.x",
    ## define a format for all stats from the used sfun_simple function
    quantiles = "xx.x - xx.x", 
    median_range = "xx.x (xx.x - xx.x)", 
    mean_ci_3d = "xx.x (xx.x - xx.x)"
  )
  
  .formats_defaults <- .formats_defaults_all[.stats]

  # this line will ensure .formats is restricted to requested .stats
  # and the order of the .formats specification is no longer important
  .formats <- .formats[.stats]
  
  # add the default formats for the stats that had no format defined in .formats
  .formats <- .formats[!is.na(.formats)]
  miss_formats_names <- setdiff(names(.formats_defaults), names(.formats))
  miss_formats <- .formats_defaults[miss_formats_names]
  .formats <- c(.formats, miss_formats)
  .formats <- .formats[.stats]
  
  
  .labels_all <- c(n = "N",
    mean = "Mean",
    mean_se = "Mean (SE)",
    median = "Median",
    range = "Min - max",
    ## define a format for all stats from the used sfun_simple function
    quantiles = "Q1 - Q3", 
    median_range = "Median (min - max)", 
    mean_ci_3d = "Mean (95%CI)"
  )
  .labels <- .labels_all[.stats]
  
  in_rows(.list = stats, .formats = .formats, .labels = .labels)
}
```

```{r simple_afun3 }
basic_table() %>%
  split_cols_by("ARM") %>%
  analyze(vars = "AGE", afun_simple3,
          extra_args = list(
            .stats = c("n", "mean_se", "quantiles"),
            .formats = c(mean_se = "xx.x (xx.xx)")))  %>%
  build_table(adsl)

```
With this version of analysis function, the user has all flexibility regarding formatting the statistics, without too much difficulty. All with default formatting.

```{r simple_afun3 all default}
basic_table() %>%
  split_cols_by("ARM") %>%
  analyze(vars = "AGE", afun_simple3,
          extra_args = list(
            .stats = c("n", "mean_se", "quantiles")))  %>%
  build_table(adsl)

```
Or all with user-defined formatting, and anything in between (default for some, user-defined for others).
```{r simple_afun3 all overruled}
basic_table() %>%
  split_cols_by("ARM") %>%
  analyze(vars = "AGE", afun_simple3,
          extra_args = list(
            .stats = c("n", "mean_se", "quantiles"),
            .formats = c(mean_se = "xx.x (xx.xx)",
                         quantiles = "xx.xx - xx.xx")))  %>%
  build_table(adsl)

```


## formatting in `tern` and `junco` analysis functions
The formatting approach in tern function follows the logic of the last version of analysis function, `simple_afun3`, although implemented slightly differently. This difference in coding approach is beyond the scope of the current vignette.  

This implies that when using `tern` defined `afuns`, users have the flexibility to take the formats from an overall default (`tern` default), modify formats for some statistics only, or re-define formats for all statistics.

The latter method is also useful for defining company specific formats, eg at a central location.
From here onwards, examples will be based upon the `tern` function `a_summary()`.

```{r a_summary all defaults}
basic_table() %>%
  split_cols_by("ARM") %>%
  analyze(vars = "AGE",
          a_summary,
          extra_args = list(
            .stats = c("n", "mean", "mean_se")
          ))  %>%
  build_table(adsl) 
```

### tern default formats for `a_summary`
The default formats for the numerical summary can be retrieved as per below. For sake of simplicity, we restrict to the same subset of 8 statistics as above: "n", "mean", "mean_se", "median", "range", "quantiles", "median_range", "mean_ci_3d".

```{r tern default formats}
stats <- c("n", "mean", "mean_se", "median", "range", "quantiles", "median_range", "mean_ci_3d")
tern_fmt_numeric_vars <- unlist(get_formats_from_stats(stats = get_stats(method_groups = "analyze_vars_numeric")))[stats]

tern_fmt_numeric_vars
```

In our company, we have different formatting rules for some of these statistics, eg `sd` and `se` are to be presented with a digit more than `mean` and `median`. `range` is to be presented with one digit less than `mean` and `median`, which then also applies to `median_range`.


```{r company specific default formats}
mycompany_fmt_numeric_vars <- tern_fmt_numeric_vars

mycompany_fmt_numeric_vars[c("sd", "se")] <- "xx.xx"
mycompany_fmt_numeric_vars[c("mean_sd", "mean_se")] <- "xx.x (xx.xx)"

mycompany_fmt_numeric_vars["mean_ci_3d"] <- "xx.x (xx.x - xx.x)"
```

In below call, as no `.formats` argument has been included, the default `tern` formats are used.
```{r a_summary with tern default formats}
basic_table() %>%
  split_cols_by("ARM") %>%
  analyze(
    vars = "AGE", 
    a_summary, 
    extra_args = list(
      .stats = c("n", "mean", "mean_se", "mean_ci")
    )
  )  %>%
  build_table(adsl)
```

In below call, the `.formats` argument has been included to use all company specific formats.

```{r a_summary with company specific formats}
basic_table() %>%
  split_cols_by("ARM") %>%
  analyze(
    vars = "AGE",
    a_summary,
    extra_args = list(
      .stats = c("n", "mean", "mean_se", "mean_ci"),
      .formats = mycompany_fmt_numeric_vars
    )
  )  %>%
  build_table(adsl) 
```

### junco default formats
In a similar manner, we can take a look into the `junco` specific formats for numeric analysis statistics.
Note that most of these statistics have the form of a formatting function, and hence it is less obvious how the format looks like.
```{r junco default formats}

junco_fmt_numeric_vars <- junco_get_formats_from_stats(stats = get_stats(method_groups = "analyze_vars_numeric"))

is_str_style <- sapply(junco_fmt_numeric_vars, function(x){!is.function(x)})

junco_str_style <- junco_fmt_numeric_vars[is_str_style]
junco_fun_style <- junco_fmt_numeric_vars[!is_str_style]

names(junco_str_style)
names(junco_fun_style)

unlist(junco_str_style)

```

With below approach, by applying the formatting functions to an example, you can get an idea of the formatting specifications from the junco default formats.
```{r}
 set.seed(1)
 x <- runif(n = 20, min = 0, max = 100)
 stats <- s_summary(x)
 
 stats_fun <- stats[names(junco_fun_style)]
 
 stats_fmted <- sapply(names(stats_fun), function(x){
  fmt <- junco_fun_style[[x]] 
  res <- format_value(stats_fun[[x]], fmt)
  res <- gsub("[0-9]", "x", res)
  })
 
 stats_fmted
```
Here is an example where the junco default formats are used in a `tern` `afun`.
```{r a_summary with junco default formats}
basic_table() %>%
  split_cols_by("ARM") %>%
  analyze(
    vars = "AGE",
    a_summary,
    extra_args = list(
      .stats = c("n", "mean", "mean_sd", "mean_ci"),
      .formats = junco_fmt_numeric_vars
    )
  )  %>%
  build_table(adsl) 
```

### junco formats issue
Note that the junco formats are not yet in line with the JJ specifications for core numerical statistics.

The following should be updated (assumption, incoming data has decimal precision of 1)

- mean and median: "xx.xx"
- sd and se, geom_sd, geom_se: "xx.xxx"
- mean_sd and mean_se: "xx.xx (xx.xxx)"
- range: "xx.x, xx.x"
- median_range: "xx.xx (xx.x - xx.x)"

- cv, mad, iqr: ?


```{r TODO junco formats}
## TODO : junco formats for num vars are not according to jj specs - add to backlog!!!
## Question : would updates impact TLG/tests?
```

## Controlling decimal precision
In the above format specification, including the `tern` and `junco` defaults, the decimal precision is included in the formatting string, and the same precision is used for all cell splits.

Often it is required to have different precision specifications for different cell splits. Eg in a laboratory/vital signs table, depending on the decimal precision of the parameter to analyze, different formats have to be applied.


```{r advs dataset}
advs <- ex_advs %>%
  select(USUBJID, ARM, PARAMCD, PARAM, AVAL, AVISIT, ATPTN) %>%
  filter(AVISIT == "WEEK 1 DAY 8") %>%
  filter(PARAMCD %in% c("DIABP", "PULSE", "RESP")) %>%
  mutate(dp = case_when(
    PARAMCD == "DIABP" ~ 0,
    PARAMCD == "PULSE" ~ 1,
    PARAMCD == "RESP" ~ 2
  )) %>% 
  mutate(AVAL2 = round(AVAL, dp))
```

In `tern` there is an option to include an `auto` format to handle this requirement.

### auto format feature in tern

Note that the `auto` specification cannot be used with `analyze` and `afun = a_summary`, to use this feature we have to switch to the layout variant `analyze_vars`.

```{r}
basic_table() %>%
  split_cols_by("ARM") %>%
  split_rows_by("PARAMCD", split_fun = drop_split_levels) %>% 
  analyze_vars(
    vars = c("AVAL2"),
    .stats = c("n", "mean", "mean_se", "mean_ci"),
    .formats = c(
      "mean" = "auto",
      "mean_se" = "auto",
      "mean_ci" = "auto"
    )
  )  %>%
  build_table(advs)
```
In the resulting table, the decimal precision of each parameter is adjusted according to the incoming data.

The only problem we have with current approach is that we cannot control the format specifications to meet our company rules: `mean` has to be presented with 1 decimal more than incoming data, `se` and `sd` with 2 more, etc.

For this reason we need further customization to formatting specification in analysis functions.

```{r}
## TODO : continue with approach after discussion/agreement on how to implement this in junco in future.
```

## rounding method: iec vs sas

### round_type argument in `formatters`
In `formatters` version 0.5.11 onwards, a new argument `round_type` is available in `formatters::format_value` and all formatting machinery.

For formatting functions, whenever round_type is an argument of the function, it will be passed onto the core formatting behaviour.
The same applies for the argument `na_str`.


Despite the availability of `round_method`, we still need formatting functions to apply the sas rounding method, as `rtables::rcell` does not yet accept the `round_type` argument.

TODO @Gabe : need advice here, is this a bug, or intended?

```{r example}
df <- data.frame(var1 = c(0.2, 0.2, 0.3, 0.3))

stats <- s_summary(df[["var1"]])
med <- stats[["median"]]

format_value(med, "xx.x", round_type = "iec")
format_value(med, "xx.x", round_type = "sas")

format_rcell(med, format = "xx.x", round_type = "sas")

format_rcell(med, format = "xx.x", round_type = "sas")

### @Gabe : how to pass round_type to rcell/in_rows, this is the core method used in all tern/junco afuns?
# rcell(med, format = "xx.x", round_type = "sas")
### is it possible that round_type should also have been included in definition of rtables functions rcell and CellValue (and RowsVerticalSection)?

# works fine with rcell and formatting function that controls rounding method, if rounding method argument is passed to that formatting function
rcell(med, format = format_xx_fct(roundmethod = "sas")("xx.x"))
rcell(med, format = format_xx_fct(roundmethod = "iec")("xx.x"))
```

### example of rounding method in analyze call with formatting function
When we control the rounding method via formatting function directly, this can be used in a rtables call as in below example.

```{r rounding method via formatting function}
basic_table() %>%
  analyze(
    vars = c("var1"),
    afun = a_summary,
    extra_args = list(
      .stats = c("n", "median", "mean"),
      .formats = c(median = format_xx_fct(roundmethod = "sas")("xx.x"),
                   mean = format_xx_fct(roundmethod = "sas")("xx.x")))
  )  %>%
  build_table(df)

basic_table() %>%
  analyze(
    vars = c("var1"),
    afun = a_summary,
    extra_args = list(
      .stats = c("n", "median", "mean", "mean_ci_3d"),
      .formats = c(median = format_xx_fct(roundmethod = "iec")("xx.x"),
                   mean = format_xx_fct(roundmethod = "iec")("xx.x"),
                   mean_ci_3d = format_xx_fct(roundmethod = "iec")("xx.x (xx.x, xx.x)"))
  ))  %>%
  build_table(df)

```
Here is a further enhancement of previously defined analyis function that controls the rounding method and formatting function applied.

```{r afun_simple4 round_type}
afun_simple4 <- function(df,
                         .var,
                         .stats = c("n", "mean", "mean_se", "median", "range"),
                         .formats = NULL,
                         round_type = c("iec", "sas"),
                         .fmtfun = TRUE) {
  x <- df[[.var]]
  stats <- sfun_simple(x)[.stats]
  
  round_type <- match.arg(round_type)
  
  if (.fmtfun) { 
    fmtfun <- format_xx_fct(roundmethod = round_type) 
  } else {
    # formatters build in formats
    cat("formatters built in formats are used")
    fmtfun <- function(str){str}
  }
  # set default formats for all stats from the s-function
  .formats_defaults_all <- c(n = "xx",
    mean = fmtfun("xx.x"),
    mean_se = fmtfun("xx.x (xx.x)"),
    median = fmtfun("xx.x"),
    range = fmtfun("xx.x - xx.x"),
    ## define a format for all stats from the used sfun_simple function
    quantiles = fmtfun("xx.x - xx.x"), 
    median_range = fmtfun("xx.x (xx.x - xx.x)"), 
    mean_ci_3d = fmtfun("xx.x (xx.x - xx.x)")
  )
  
  .formats_defaults <- .formats_defaults_all[.stats]

  # this line will ensure .formats is restricted to requested .stats
  # and the order of the .formats specification is no longer important
  .formats <- .formats[.stats]
  
  # add the default formats for the stats that had no format defined in .formats
  .formats <- .formats[!is.na(.formats)]
  miss_formats_names <- setdiff(names(.formats_defaults), names(.formats))
  miss_formats <- .formats_defaults[miss_formats_names]
  .formats <- c(.formats, miss_formats)
  .formats <- .formats[.stats]
  
  
  .labels_all <- c(n = "N",
    mean = "Mean",
    mean_se = "Mean (SE)",
    median = "Median",
    range = "Min - max",
    ## define a format for all stats from the used sfun_simple function
    quantiles = "Q1 - Q3", 
    median_range = "Median (min - max)", 
    mean_ci_3d = "Mean (95%CI)"
  )
  .labels <- .labels_all[.stats]
  
  in_rows(.list = stats, .formats = .formats, .labels = .labels)
}
```

In below example you can see that the proper rounding type has been applied in both examples.

```{r apply afun_simple4 with formatting function}
basic_table() %>%
  analyze(
    vars = c("var1"),
    afun = afun_simple4,
    extra_args = list(
      round_type = "sas")
  )  %>%
  build_table(df)

basic_table() %>%
  analyze(
    vars = c("var1"),
    afun = afun_simple4,
    extra_args = list(
      round_type = "iec")
  )  %>%
  build_table(df)
```

### Challenge 

@Gabe TODO As mentioned earlier, it is not clear on how to utilize round_type with built in formatters formats using a afun that builds the rows using in_rows.

Here the iec rounding has been applied, whereas we wanted to have the table using sas rounding.

```{r apply afun_simple4 without formatting function}
### round_type is ignored when formatters based char formats
basic_table() %>%
  analyze(
    vars = c("var1"),
    afun = afun_simple4,
    extra_args = list(
      round_type = "sas",
      .fmtfun = FALSE)
  )  %>%
  build_table(df)
```




